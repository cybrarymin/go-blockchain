* Merkle proof
:PROPERTIES:
:TOC: :include descendants
:END:

:CONTENTS:
- [[#concepts-and-purpose][Concepts and purpose]]
  - [[#merkle-tree-and-transaction-hashing][Merkle tree and transaction hashing]]
  - [[#merkle-proof-and-inclusion-verification][Merkle proof and inclusion verification]]
- [[#design-and-implementation][Design and implementation]]
  - [[#merkle-hash-and-construction-of-merkle-tree][Merkle hash and construction of Merkle tree]]
  - [[#merkle-prove-and-derivation-of-merkle-proof][Merkle prove and derivation of Merkle proof]]
  - [[#merkle-verify-and-inclusion-verification][Merkle verify and inclusion verification]]
  - [[#grpc-txprove-method][gRPC TxProve method]]
  - [[#grpc-txverify-method][gRPC TxVerify method]]
- [[#testing-and-usage][Testing and usage]]
  - [[#testing-merkle-hash-prove-and-verify][Testing Merkle hash, prove, and verify]]
  - [[#testing-grpc-txprove-and-txverify-methods][Testing gRPC TxProve and TxVerify methods]]
  - [[#using-tx-prove-and-tx-verify-commands][Using tx prove and tx verify commands]]
:END:

** Concepts and purpose

*** Merkle tree and transaction hashing

- Merkle tree :: The Merkle tree is a binary tree where each leaf is a hash of
  an element from a set of elements e.g. transaction in a block, and every
  parent node up to the root is a hash of its children. The merkle tree
  summarizes a set of elements into a single hash of the root in a similar way
  that a single hash over the whole set of elements, but with considerable
  benefits in terms of computational efficiency and minimized network transfers.
  Both the Merkle root and the single hash convert the whole set of elements
  into a single hash, but the Merkle tree allows for *efficient verification of
  inclusion of elements* into a set of elements with minimal computation and
  network transfers, while the single hash requires hashing the whole set of
  elements for every inclusion verification. The efficient verification of
  inclusion of elements in a set of elements is used in blockchains to securely
  prove the inclusion of a transaction in a block specifically for light
  clients. For this purpose the Merkle root of all block transactions is
  included in the block header. The Merkle tree is used to securely *verify the
  integrity of elements* in a set of elements. If the computed Merkle root over
  the received set of elements does not matches the securely provided Merkle
  root of the original set of elements, that some received elements are
  corrupted. This characteristic of the Merkle tree is used in blockchains to
  ensure integrity of transactions in a block that is propagated through the
  peer to peer network. The Merkle tree allows for *efficient identification of
  differences between two sets of elements*. This provides an efficient way to
  compute minimal differences that have to be transmitted over the network in
  order to synchronize the two sets of elements. This feature is used in
  distributed source code version control systems e.g. Git and distributed
  peer-to-peer networks for file sharing e.g. Torrent

*** Merkle proof and inclusion verification

- Merkle proof :: The Merkle proof is a set of hashes with the left or right
  position indication following the Merkle path of the binary search over the
  Merkle tree starting for the specific element hash in the leaf up to the
  Merkle root. The Merkle proof is used for efficient verification of inclusion
  of elements into a set of elements. The Merkle proof provides to the verifying
  party the minimal set of required hashes to compute the Merkle root from the
  hash of the element whose inclusion in a set of elements has to be verified.
  The Merkle root starts from the hash of the element in the leaf position,
  following missing hashes of sibling nodes on the path of the reverse binary
  search in order to compute hashes of parent nodes on the path of the reverse
  binary search up to the Merkle root. Each hash has attached position label
  that indicates the left or the right child of the Merkle tree. This
  information is used to correctly verify the provided Merkle proof
- Merkle proof verification :: In order to verify the inclusion of an element
  into a set of elements the verifying party only needs to securely receive from
  a trusted source the hash of the element whose inclusion has to be verified,
  and the Merkle root of the whole set of elements. The verifying party requests
  to the proving party the Merkle proof for the hash of the element. The proving
  party derives the Merkle proof from the Merkle tree and the requested hash of
  the element. The proving party returns to the Merkle proof to the verifying
  party. The verifying party computes the Merkle root recursively combining
  hashes from the provided Merkle proof in the indicated by hash positions
  order. If the computed Merkle root equals to the previously received from a
  trusted source Merkle root of the set of elements, the element is included in
  the set of elements with the high level of security. If the computed Merkle
  proof is not equal to the securely received Merkle proof either the element is
  not included in the set of elements or the Merkle proof is incorrectly derived
  or corrupted. Only the hash of the element and the Merkle root of the whole
  set of elements has to be received from a trusted source. While the Merkle
  proof can be received from a less trusted source as it is nearly impossible to
  counterfeit a correct Merkle proof for a set of elements where the requested
  element is not included
- Merkle proof security :: The security of the Merkle proof relies on
  cryptographic characteristics of the underlying hash function. Specifically,
  the second pre-image resistance and the collision resistance of the hash
  function. The *second pre-image resistance* states that given an input and the
  hash of the input, it is almost impossible to find another input that has the
  same hash. The second pre-image resistance makes it very difficult to
  counterfeit a correct Merkle proof for an element that is not included in the
  set of elements. The *collision resistance* states that it is almost
  impossible to find two different inputs that have the same hash. Collisions
  are inevitable because the output length is fixed, while the input is
  arbitrary large. The collision resistance makes it very difficult to find the
  second different set that satisfies the Merkle proof derived from the Merkle
  tree of the original set of elements. The *deterministic nature of the hash
  function* makes Merkle proofs reproducible and verifiable. The Merkle tree
  allows securely substitute the whole set of elements with a much smaller tree
  of hashes that uniquely represents the the original set with the added benefit
  for for efficient verification of inclusion of elements into the set of
  elements, the verification of integrity of the set of elements, and the
  efficiency way to synchronize out-of-sync sets of elements by transferring
  minimal differences between sets of elements
- Merkle proof efficiency :: The efficiency of Merkle proof relies on the
  structure of the underlying binary tree with *logarithmic characteristics of
  the binary search*. To verify the inclusion of an element into a set of
  elements only a log(N) hashes from the Merkle proof have to be transferred
  over the network, and only log(N) combinations of hashes has to be computed to
  reach the Merkle root. When not using the Merkle proof, the whole set of
  elements has to be transferred over the network, the integrity of the set has
  to be verified, and only that the inclusion of the element can be checked.
  This results in a much larger network transfers and computation overhead
  needed to verify the integrity of the whole set of elements

** Design and implementation

*** Merkle hash and construction of Merkle tree

- Array representation of binary tree :: The array representation of a binary
  tree uses the linear data structure to store node values for a binary tree.
  The root of the binary tree is stored in the first slot of the array. The two
  children of the root are stored in the second and the third slots of the
  array. Next the children of the first root child are stored in the consecutive
  array slots and so on. Finally, the leaves of the binary tree are stored at
  the end of the array. The binary tree is stored in the array sequentially
  level by level starting from the root down to the leaves. Missing nodes in the
  binary tree are represented by the default values in the corresponding array
  slots. The benefit of the array representation of a binary tree is the
  *compact representation of the binary* tree without the overhead of the node
  links required in the node-based linked representation of the binary tree.
  Another benefit of the array representation is the *fast random access to
  nodes* of the binary tree through the indexing of the array, instead of
  sequential node-to-node following of links linked representation. The next
  benefit of the array representation is the *natural applicability of iterative
  algorithms* that does not consume the call stack, instead of the recursive
  algorithms that consume the call stack in the case of the linked
  representation. This implementation of the Merkle tree uses the array
  representation of the Merkle tree
- Merkle hash algorithm :: The Merkle hash algorithm constructs the Merkle tree
  from a list of transactions. The Merkle hash algorithm takes the list of
  transaction, the ~typeHash(T) H~ function to hash a transaction and the
  ~pairHash(H, H) H~ function to combine two hashes of node children in order to
  produce a parent hash. The Merkle hash algorithm returns the array
  representation of the constructed Merkle tree as a slice of hashes conforming
  to the rules of the array representation. The Merkle root in the first element
  of the array representation of the Merkle tree. The Merkle hash algorithm is
  generic. The generic parameters are the *type of transactions* or set elements
  and the *type of hash values* e.g. Keccak256, SHA256 that must be comparable.
  This design allow to apply the Merkle hash algorithm to different types of
  transactions and different types of hash functions. Specifically this
  implementation uses two different hash functions. One hash function is the
  easy to visualize and debug simple string concatenation for learning purposes
  and testing. The other hash function is the Keccak256 hash function that is
  used everywhere in the proposed blockchain, but is much challenging to debug.
  The Merkle hash algorithm first checks that the provided list of transactions
  is not empty. Then the list of transaction hashes is created by applying the
  type hash function to each transaction in the input list. Next the length of
  the array representation of the Merkle tree is calculated, and the Merkle tree
  array is created. Then the list of transaction hashes if copied into the end
  of the Merkle tree array. Next the hashes of transactions are combined in
  pairs to produce the next level of nodes of the Merkle tree. These nodes are
  stored just before the list of transaction hashes in the Merkle tree array.
  The same process iteratively computes hashes of every successive level of
  parent nodes and stores them just before the nodes of the previous level of
  the Merkle tree up until producing the Merkle root in the first slot of the
  Merkle tree array. Hashes of the previous level are needed to construct the
  next level of nodes in the Merkle tree using the pair hash function. The
  Merkle hash algorithm
  - Check that the input list of transaction is not empty
  - Produce the list of transaction hashes by applying the type hash function to
    the input list of transactions
  - Compute the length of the array representation of the Merkle tree
  - Create the array to represent the Merkle tree and initialize the array with
    default values
  - Copy the list of transaction hashes into the end of the Merkle tree array
  - Iteratively compute each successive level of nodes by combining pair of
    hashes from the previous level applying the pair hash function
  - Each next level of nodes is stored in the Merkle tree array just before the
    previous level of nodes
  - The process of combining pair of hashes continues up until producing the
    Merkle root in the first slot of the Merkle tree array
  #+BEGIN_SRC go
func MerkleHash[T any, H comparable](
  txs []T, typeHash func(T) H, pairHash func(H, H) H,
) ([]H, error) {
  if len(txs) == 0 {
    return nil, fmt.Errorf("merkle hash: empty transaction list")
  }
  htxs := make([]H, len(txs))
  for i, tx := range txs {
    htxs[i] = typeHash(tx)
  }
  halfFloor := func(i int) int {
    return int(math.Floor(float64(i / 2)))
  }
  l := int(math.Pow(2, math.Ceil(math.Log2(float64(len(htxs)))) + 1) - 1)
  merkleTree := make([]H, l)
  chd := halfFloor(l)
  for i, j := 0, chd; i < len(htxs); i, j = i + 1, j + 1 {
    merkleTree[j] = htxs[i]
  }
  l, par := chd * 2, halfFloor(chd)
  for chd > 0 {
    for i, j := chd, par; i < l; i, j = i + 2, j + 1 {
      merkleTree[j] = pairHash(merkleTree[i], merkleTree[i + 1])
    }
    chd = halfFloor(chd)
    l, par = chd * 2, halfFloor(chd)
  }
  return merkleTree, nil
}
  #+END_SRC
- Transaction hash function :: The transaction hash function takes a transaction
  and returns a hash of the transaction. This implementation uses two different
  transaction hash functions. One transaction hash function returns the simple
  string representation of the input type. This transaction hash function is
  used for learning purposes, testing, debugging, and visual understanding of
  the internal workings of the Merkle hash, prove, and verify algorithms. The
  other transaction hash function is the Keccak256 hash function that is used in
  the implementation of this blockchain
  #+BEGIN_SRC go
// String hash for learning purposes
func typeHashStr(s string) string {
  return s
}
// Keccak256 hash for the blockchain
func NewHash(val any) Hash {
  jval, _ := json.Marshal(val)
  hash := make([]byte, 64)
  sha3.ShakeSum256(hash, jval)
  return Hash(hash[:32])
}
func TxHash(tx SigTx) Hash {
  return NewHash(tx)
}
  #+END_SRC
- Pair hash function :: The pair hash function combines hashes of a pair of
  children from the Merkle tree in order to produce the hash of the parent from
  the next level of the Merkle tree. This implementation uses two different pair
  hash functions. One pair hash function is a simple string concatenation of the
  input hashes. This pair hash function is used for learning purposes, testing,
  debugging, and visual understanding of the internal workings of the Merkle
  hash, prove, and verify algorithms. The other hash function is the Keccak256
  hash function that is used in the implementation of this blockchain. The
  combination of input hashes is performed through the concatenation of the
  string representation of the input hashes
  #+BEGIN_SRC go
// String concatenation hash for learning purposes
func pairHashStr(l, r string) string {
  if r == "" {
    return l
  }
  return l + r
}
// Keccak256 hash for the blockchain
func TxPairHash(l, r Hash) Hash {
  var nilHash Hash
  if r == nilHash {
    return l
  }
  return NewHash(l.String() + r.String())
}
  #+END_SRC

*** Merkle prove and derivation of Merkle proof

*** Merkle verify and inclusion verification

*** gRPC =TxProve= method

*** gRPC =TxVerify= method

** Testing and usage

*** Testing Merkle hash, prove, and verify

*** Testing gRPC =TxProve= and =TxVerify= methods

*** Using =tx prove= and =tx verify= commands
