* Merkle proof
:PROPERTIES:
:TOC: :include descendants
:END:

:CONTENTS:
- [[#concepts-and-purpose][Concepts and purpose]]
  - [[#merkle-tree-and-transaction-hashing][Merkle tree and transaction hashing]]
  - [[#merkle-proof-and-inclusion-verification][Merkle proof and inclusion verification]]
- [[#design-and-implementation][Design and implementation]]
  - [[#merkle-hash-and-construction-of-merkle-tree][Merkle hash and construction of Merkle tree]]
  - [[#merkle-prove-and-derivation-of-merkle-proof][Merkle prove and derivation of Merkle proof]]
  - [[#merkle-verify-and-inclusion-verification][Merkle verify and inclusion verification]]
  - [[#grpc-txprove-method][gRPC TxProve method]]
  - [[#grpc-txverify-method][gRPC TxVerify method]]
- [[#testing-and-usage][Testing and usage]]
  - [[#testing-merkle-hash-prove-and-verify][Testing Merkle hash, prove, and verify]]
  - [[#testing-grpc-txprove-and-txverify-methods][Testing gRPC TxProve and TxVerify methods]]
  - [[#using-tx-prove-and-tx-verify-commands][Using tx prove and tx verify commands]]
:END:

** Concepts and purpose

*** Merkle tree and transaction hashing

- Merkle tree :: The Merkle tree is a binary tree where each leaf is a hash of
  an element from a set of elements e.g. transaction in a block, and every
  parent node up to the root is a hash of its children. The merkle tree
  summarizes a set of elements into a single hash of the root in a similar way
  that a single hash over the whole set of elements, but with considerable
  benefits in terms of computational efficiency and minimized network transfers.
  Both the Merkle root and the single hash convert the whole set of elements
  into a single hash, but the Merkle tree allows for *efficient verification of
  inclusion of elements* into a set of elements with minimal computation and
  network transfers, while the single hash requires hashing the whole set of
  elements for every inclusion verification. The efficient verification of
  inclusion of elements in a set of elements is used in blockchains to securely
  prove the inclusion of a transaction in a block specifically for light
  clients. For this purpose the Merkle root of all block transactions is
  included in the block header. The Merkle tree is used to securely *verify the
  integrity of elements* in a set of elements. If the computed Merkle root over
  the received set of elements does not matches the securely provided Merkle
  root of the original set of elements, that some received elements are
  corrupted. This characteristic of the Merkle tree is used in blockchains to
  ensure integrity of transactions in a block that is propagated through the
  peer to peer network. The Merkle tree allows for *efficient identification of
  differences between two sets of elements*. This provides an efficient way to
  compute minimal differences that have to be transmitted over the network in
  order to synchronize the two sets of elements. This feature is used in
  distributed source code version control systems e.g. Git and distributed
  peer-to-peer networks for file sharing e.g. Torrent

*** Merkle proof and inclusion verification

- Merkle proof :: The Merkle proof is a set of hashes with the left or right
  position indication following the Merkle path of the binary search over the
  Merkle tree starting for the specific element hash in the leaf up to the
  Merkle root. The Merkle proof is used for efficient verification of inclusion
  of elements into a set of elements. The Merkle proof provides to the verifying
  party the minimal set of required hashes to compute the Merkle root from the
  hash of the element whose inclusion in a set of elements has to be verified.
  The Merkle root starts from the hash of the element in the leaf position,
  following missing hashes of sibling nodes on the path of the reverse binary
  search in order to compute hashes of parent nodes on the path of the reverse
  binary search up to the Merkle root. Each hash has attached position label
  that indicates the left or the right child of the Merkle tree. This
  information is used to correctly verify the provided Merkle proof
- Merkle proof verification :: In order to verify the inclusion of an element
  into a set of elements the verifying party only needs to securely receive from
  a trusted source the hash of the element whose inclusion has to be verified,
  and the Merkle root of the whole set of elements. The verifying party requests
  to the proving party the Merkle proof for the hash of the element. The proving
  party derives the Merkle proof from the Merkle tree and the requested hash of
  the element. The proving party returns to the Merkle proof to the verifying
  party. The verifying party computes the Merkle root recursively combining
  hashes from the provided Merkle proof in the indicated by hash positions
  order. If the computed Merkle root equals to the previously received from a
  trusted source Merkle root of the set of elements, the element is included in
  the set of elements with the high level of security. If the computed Merkle
  proof is not equal to the securely received Merkle proof either the element is
  not included in the set of elements or the Merkle proof is incorrectly derived
  or corrupted. Only the hash of the element and the Merkle root of the whole
  set of elements has to be received from a trusted source. While the Merkle
  proof can be received from a less trusted source as it is nearly impossible to
  counterfeit a correct Merkle proof for a set of elements where the requested
  element is not included
- Merkle proof security :: The security of the Merkle proof relies on
  cryptographic characteristics of the underlying hash function. Specifically,
  the second pre-image resistance and the collision resistance of the hash
  function. The *second pre-image resistance* states that given an input and the
  hash of the input, it is almost impossible to find another input that has the
  same hash. The second pre-image resistance makes it very difficult to
  counterfeit a correct Merkle proof for an element that is not included in the
  set of elements. The *collision resistance* states that it is almost
  impossible to find two different inputs that have the same hash. Collisions
  are inevitable because the output length is fixed, while the input is
  arbitrary large. The collision resistance makes it very difficult to find the
  second different set that satisfies the Merkle proof derived from the Merkle
  tree of the original set of elements. The *deterministic nature of the hash
  function* makes Merkle proofs reproducible and verifiable. The Merkle tree
  allows securely substitute the whole set of elements with a much smaller tree
  of hashes that uniquely represents the the original set with the added benefit
  for for efficient verification of inclusion of elements into the set of
  elements, the verification of integrity of the set of elements, and the
  efficiency way to synchronize out-of-sync sets of elements by transferring
  minimal differences between sets of elements
- Merkle proof efficiency :: The efficiency of Merkle proof relies on the
  structure of the underlying binary tree with *logarithmic characteristics of
  the binary search*. To verify the inclusion of an element into a set of
  elements only a log(N) hashes from the Merkle proof have to be transferred
  over the network, and only log(N) combinations of hashes has to be computed to
  reach the Merkle root. When not using the Merkle proof, the whole set of
  elements has to be transferred over the network, the integrity of the set has
  to be verified, and only that the inclusion of the element can be checked.
  This results in a much larger network transfers and computation overhead
  needed to verify the integrity of the whole set of elements

** Design and implementation

*** Merkle hash and construction of Merkle tree

- Array representation of binary tree :: The array representation of a binary
  tree uses the linear data structure to store node values for a binary tree.
  The root of the binary tree is stored in the first slot of the array. The two
  children of the root are stored in the second and the third slots of the
  array. Next the children of the first root child are stored in the consecutive
  array slots and so on. Finally, the leaves of the binary tree are stored at
  the end of the array. The binary tree is stored in the array sequentially
  level by level starting from the root down to the leaves. Missing nodes in the
  binary tree are represented by the default values in the corresponding array
  slots. The children of a node in the position =i= are at the ~2i + 1~ odd left
  and the ~2i + 2~ even right positions. The parent for the odd left child in
  the position =i= is at the ~(i - 1) / 2~ position. The parent for the even
  right child in the position =i= is at the ~(i - 2) / 2~ position. The benefit
  of the array representation of a binary tree is the *compact representation of
  the binary* tree without the overhead of the node links required in the
  node-based linked representation of the binary tree. Another benefit of the
  array representation is the *fast random access to nodes* of the binary tree
  through the indexing of the array, instead of sequential node-to-node
  following of links linked representation. The next benefit of the array
  representation is the *natural applicability of iterative algorithms* that
  does not consume the call stack, instead of the recursive algorithms that
  consume the call stack in the case of the linked representation. This
  implementation of the Merkle tree uses the array representation of the Merkle
  tree
- Merkle hash algorithm :: The Merkle hash algorithm constructs the Merkle tree
  from a list of transactions. The Merkle hash algorithm takes the list of
  transaction, the ~typeHash(T) H~ function to hash a transaction and the
  ~pairHash(H, H) H~ function to combine two hashes of node children in order to
  produce a parent hash. The Merkle hash algorithm returns the array
  representation of the constructed Merkle tree as a slice of hashes conforming
  to the rules of the array representation. The Merkle root in the first element
  of the array representation of the Merkle tree. The Merkle hash algorithm is
  generic. The generic parameters are the *type of transactions* or set elements
  and the *type of hash values* e.g. Keccak256, SHA256 that must be comparable.
  This design allow to apply the Merkle hash algorithm to different types of
  transactions and different types of hash functions. Specifically this
  implementation uses two different hash functions. One hash function is the
  easy to visualize and debug simple string concatenation for learning purposes
  and testing. The other hash function is the Keccak256 hash function that is
  used everywhere in the proposed blockchain, but is much challenging to debug.
  The Merkle hash algorithm first checks that the provided list of transactions
  is not empty. Then the list of transaction hashes is created by applying the
  type hash function to each transaction in the input list. Next the length of
  the array representation of the Merkle tree is calculated, and the Merkle tree
  array is created. Then the list of transaction hashes if copied into the end
  of the Merkle tree array. Next the hashes of transactions are combined in
  pairs to produce the next level of nodes of the Merkle tree. These nodes are
  stored just before the list of transaction hashes in the Merkle tree array.
  The same process iteratively computes hashes of every successive level of
  parent nodes and stores them just before the nodes of the previous level of
  the Merkle tree up until producing the Merkle root in the first slot of the
  Merkle tree array. Hashes of the previous level are needed to construct the
  next level of nodes in the Merkle tree using the pair hash function. The
  Merkle hash algorithm
  - Check that the input list of transaction is not empty
  - Produce the list of transaction hashes by applying the type hash function to
    the input list of transactions
  - Compute the length of the array representation of the Merkle tree
  - Create the array to represent the Merkle tree and initialize the array with
    default values
  - Copy the list of transaction hashes into the end of the Merkle tree array
  - Iteratively compute each successive level of nodes by combining pair of
    hashes from the previous level applying the pair hash function
  - Each next level of nodes is stored in the Merkle tree array just before the
    previous level of nodes
  - The process of combining pair of hashes continues up until producing the
    Merkle root in the first slot of the Merkle tree array
  #+BEGIN_SRC go
func MerkleHash[T any, H comparable](
  txs []T, typeHash func(T) H, pairHash func(H, H) H,
) ([]H, error) {
  if len(txs) == 0 {
    return nil, fmt.Errorf("merkle hash: empty transaction list")
  }
  htxs := make([]H, len(txs))
  for i, tx := range txs {
    htxs[i] = typeHash(tx)
  }
  halfFloor := func(i int) int {
    return int(math.Floor(float64(i / 2)))
  }
  l := int(math.Pow(2, math.Ceil(math.Log2(float64(len(htxs)))) + 1) - 1)
  merkleTree := make([]H, l)
  chd := halfFloor(l)
  for i, j := 0, chd; i < len(htxs); i, j = i + 1, j + 1 {
    merkleTree[j] = htxs[i]
  }
  l, par := chd * 2, halfFloor(chd)
  for chd > 0 {
    for i, j := chd, par; i < l; i, j = i + 2, j + 1 {
      merkleTree[j] = pairHash(merkleTree[i], merkleTree[i + 1])
    }
    chd = halfFloor(chd)
    l, par = chd * 2, halfFloor(chd)
  }
  return merkleTree, nil
}
  #+END_SRC
- Transaction hash function :: The transaction hash function takes a transaction
  and returns a hash of the transaction. This implementation uses two different
  transaction hash functions. One transaction hash function returns the simple
  string representation of the input type. This transaction hash function is
  used for learning purposes, testing, debugging, and visual understanding of
  the internal workings of the Merkle hash, prove, and verify algorithms. The
  other transaction hash function is the Keccak256 hash function that is used in
  the implementation of this blockchain
  #+BEGIN_SRC go
// String hash for learning purposes
func typeHashStr(s string) string {
  return s
}
// Keccak256 hash for the blockchain
func NewHash(val any) Hash {
  jval, _ := json.Marshal(val)
  hash := make([]byte, 64)
  sha3.ShakeSum256(hash, jval)
  return Hash(hash[:32])
}
func TxHash(tx SigTx) Hash {
  return NewHash(tx)
}
  #+END_SRC
- Pair hash function :: The pair hash function combines hashes of a pair of
  children from the Merkle tree in order to produce the hash of the parent from
  the next level of nodes of the Merkle tree. This implementation uses two
  different pair hash functions. One pair hash function is a simple string
  concatenation of the input hashes. This pair hash function is used for
  learning purposes, testing, debugging, and visual understanding of the
  internal workings of the Merkle hash, prove, and verify algorithms. The
  combination of input hashes is performed through the concatenation of the
  string representation of the input hashes. If the hash of the right child has
  the default value, the hash of the left child is returned. The other hash
  function is the Keccak256 hash function that is used in the implementation of
  this blockchain. If the hash of the right child has the default value, the
  hash of the left child is returned
  #+BEGIN_SRC go
// String concatenation hash for learning purposes
func pairHashStr(l, r string) string {
  if r == "" {
    return l
  }
  return l + r
}
// Keccak256 hash for the blockchain
func TxPairHash(l, r Hash) Hash {
  var nilHash Hash
  if r == nilHash {
    return l
  }
  return NewHash(l.String() + r.String())
}
  #+END_SRC

Examples of array representation of Merkle trees for different input lists of
elements using the string hash function and the string concatenation pair hash
function
| Input list of elements | Array representation of Merkle tree                |
| =[1 2 3]=              | =[123 12 3 1 2 3 _]=                               |
| =[1 2 3 4]=            | =[1234 12 34 1 2 3 4]=                             |
| =[1 2 3 4 5]=          | =[12345 1234 5 12 34 5 _ 1 2 3 4 5 _ _ _]=         |
| =[1 2 3 4 5 6]=        | =[123456 1234 56 12 34 56 _ 1 2 3 4 5 6 _ _]=      |
| =[1 2 3 4 5 6 7]=      | =[1234567 1234 567 12 34 56 7 1 2 3 4 5 6 7 _]=    |
| =[1 2 3 4 5 6 7 8]=    | =[12345678 1234 5678 12 34 56 78 1 2 3 4 5 6 7 8]= |

*** Merkle prove and derivation of Merkle proof

- Merkle proof type :: The Merkle proof is a sequence of proof steps starting
  from the leaf hash of the specific element, following the missing hashes of
  sibling nodes on the path of the reverse binary search up until, but not
  including the Merkle root. All Merkle proofs start from the hash of the
  specific element and lead but do not include the Merkle root. The =Proof= type
  represents a step in the Merkle proof of inclusion of the specific element
  into the list of elements. The proof step contains either a hash of the
  specific element in the leaf position or a hash of the combination of hashes
  of two node children along with the left or right position of the hash in the
  Merkle tree. The hash is required to verify the Merkle proof. The position is
  required to correctly combine hashes of proof steps during the verification of
  the Merkle proof. The proof type is generic. The type of the hash value is
  parameterized. This design allows to use the same Merkle prove algorithm for
  derivation of Merkle proofs from Merkle trees constructed using different hash
  functions e.g. Keccak256, SHA256
  #+BEGIN_SRC go
type position int

const (
  Left position = 1
  Right position = 2
)

type Proof[H comparable] struct {
  Hash H `json:"hash"`
  Pos position `json:"pos"`
}

func newProof[H comparable](hash H, pos position) Proof[H] {
  return Proof[H]{Hash: hash, Pos: pos}
}
  #+END_SRC
- Merkle prove algorithm :: The Merkle prove algorithm derives a Merkle proof
  from the hash of a transaction whose inclusion into a list of transaction has
  to be proven, and the Merkle tree constructed from the list of transactions.
  The derived Merkle proof allows a verifying party to securely verify that the
  requested transaction has been included into the list of transaction of a
  block if the computed Merkle root from the provided Merkle hash equals to the
  received Merkle root from a trusted source. The Merkle proof guides the
  re-construction of the Merkle root from the transaction hash by providing the
  missing hashes of the sibling nodes on the path of the reversed binary search
  starting from the hash of the transaction in the leaf position and ending, but
  not including the Merkle root. The Merkle prove algorithm is generic. The type
  of the hash value is parameterized. This design allows the Merkle prove
  algorithm to work without modifications with different Merkle trees produced
  using different hash functions e.g. Keccak256, SHA256. The derived Merkle
  proof is also parameterized by the type of the hash value. The Merkle prove
  algorithm first checks if the input Merkle tree is not empty. Then the
  algorithm checks that the hash of the requested transaction is in the second
  half of the array representation of the provided Merkle tree. If the hash of
  the transaction is not in the Merkle tree the Merkle proof cannot be derived.
  Next the edge cases of the list with one and two transactions (three nodes in
  the Merkle tree) are handled. Then the first two steps of the Merkle proof are
  handled separately because they operate on the same level of the Merkle tree,
  while all other steps always move one level up until reaching the Merkle root.
  If the hash of the requested transaction is in the even right position in the
  Merkle tree, then the left sibling hash and then the transaction hash are
  included into the Merkle proof. If the hash of the requested transaction is in
  the odd left position, then the transaction hash and the right sibling hash,
  if present, are included into the Merkle proof. Next the parent position for
  the current hash is calculated depending whether the current hash position is
  even right or odd left following the rules of array representation of the
  binary tree. When the resulting parent position is even right, the sibling
  parent position will be odd left in the previous array slot. When the
  resulting parent position is odd left, the sibling parent position will be the
  even right in the next array slot. Finally the sibling parent hash, if
  present, is included into the Merkle proof with the correct position label.
  Specifically, even positions are right, and odd positions are left. The
  reverse binary search process ends when either the odd left child with index 1
  or the even right child with index 2 of the Merkle root with index 0 is
  reached. The Merkle prove algorithm
  - Check that the provided Merkle tree is not empty
  - Check that the hash of the requested transaction is in the second half of
    the array representation of the provided Merkle tree
  - Handle the edge cases of the list of one or two transactions
  - Include into the Merkle proof the first two (sometimes one) sibling hashes
    from the same level of the Merkle tree. One of these hashes will always be
    the hash of the requested transaction
  - Calculate the position of the parent hash for the current hash
  - Move to the hash of the sibling parent
  - Include the hash of the sibling parent into the Merkle proof with the
    correct position label
  - Stop the process when either the two children of the Merkle root is reached
  #+BEGIN_SRC go
func MerkleProve[H comparable](txh H, merkleTree []H) ([]Proof[H], error) {
  if len(merkleTree) == 0 {
    return nil, fmt.Errorf("merkle prove: empty merkle tree")
  }
  start := int(math.Floor(float64(len(merkleTree) / 2)))
  i := slices.Index(merkleTree[start:], txh)
  if i == -1 {
    return nil, fmt.Errorf("merkle prove: transaction %v not found", txh)
  }
  i += start
  if len(merkleTree) == 1 {
    return []Proof[H]{newProof(merkleTree[0], Left)}, nil
  }
  if len(merkleTree) == 3 {
    return []Proof[H]{
      newProof(merkleTree[1], Left), newProof(merkleTree[2], Right),
    }, nil
  }
  merkleProof := make([]Proof[H], 0)
  var nilHash H
  if i % 2 == 0 {
    merkleProof = append(merkleProof, newProof(merkleTree[i - 1], Left))
    merkleProof = append(merkleProof, newProof(merkleTree[i], Right))
    i--
  } else {
    merkleProof = append(merkleProof, newProof(merkleTree[i], Left))
    hash := merkleTree[i + 1]
    if hash != nilHash {
      merkleProof = append(merkleProof, newProof(hash, Right))
    }
    i++
  }
  for {
    if i % 2 == 0 {
      i = (i - 2) / 2
    } else {
      i = (i - 1) / 2
    }
    if i % 2 == 0 {
      i--
    } else {
      i++
    }
    hash := merkleTree[i]
    if hash != nilHash {
      if i % 2 == 0 {
        merkleProof = append(merkleProof, newProof(hash, Right))
      } else {
        merkleProof = append(merkleProof, newProof(hash, Left))
      }
    }
    if i == 2 || i == 1 {
      break
    }
  }
  return merkleProof, nil
}
  #+END_SRC

Examples of correct Merkle proofs for each element of different input lists of
elements using the string hash function and the string concatenation pair hash
function. Each Merkle proof is a sequence of hashes labeled with the left (L) or
the right (R) position needed for the verification of the Merkle proof
#+BEGIN_SRC go
Tree (1) [1]
Proof 1 [1-L] valid

Tree (2) [12 1 2]
Proof 1 [1-L 2-R] valid
Proof 2 [1-L 2-R] valid

Tree (3) [123 12 3 1 2 3 _]
Proof 1 [1-L 2-R 3-R] valid
Proof 2 [1-L 2-R 3-R] valid
Proof 3 [3-L 12-L] valid

Tree (4) [1234 12 34 1 2 3 4]
Proof 1 [1-L 2-R 34-R] valid
Proof 2 [1-L 2-R 34-R] valid
Proof 3 [3-L 4-R 12-L] valid
Proof 4 [3-L 4-R 12-L] valid

Tree (5) [12345 1234 5 12 34 5 _ 1 2 3 4 5 _ _ _]
Proof 1 [1-L 2-R 34-R 5-R] valid
Proof 2 [1-L 2-R 34-R 5-R] valid
Proof 3 [3-L 4-R 12-L 5-R] valid
Proof 4 [3-L 4-R 12-L 5-R] valid
Proof 5 [5-L 1234-L] valid

Tree (6) [123456 1234 56 12 34 56 _ 1 2 3 4 5 6 _ _]
Proof 1 [1-L 2-R 34-R 56-R] valid
Proof 2 [1-L 2-R 34-R 56-R] valid
Proof 3 [3-L 4-R 12-L 56-R] valid
Proof 4 [3-L 4-R 12-L 56-R] valid
Proof 5 [5-L 6-R 1234-L] valid
Proof 6 [5-L 6-R 1234-L] valid

Tree (7) [1234567 1234 567 12 34 56 7 1 2 3 4 5 6 7 _]
Proof 1 [1-L 2-R 34-R 567-R] valid
Proof 2 [1-L 2-R 34-R 567-R] valid
Proof 3 [3-L 4-R 12-L 567-R] valid
Proof 4 [3-L 4-R 12-L 567-R] valid
Proof 5 [5-L 6-R 7-R 1234-L] valid
Proof 6 [5-L 6-R 7-R 1234-L] valid
Proof 7 [7-L 56-L 1234-L] valid

Tree (8) [12345678 1234 5678 12 34 56 78 1 2 3 4 5 6 7 8]
Proof 1 [1-L 2-R 34-R 5678-R] valid
Proof 2 [1-L 2-R 34-R 5678-R] valid
Proof 3 [3-L 4-R 12-L 5678-R] valid
Proof 4 [3-L 4-R 12-L 5678-R] valid
Proof 5 [5-L 6-R 78-R 1234-L] valid
Proof 6 [5-L 6-R 78-R 1234-L] valid
Proof 7 [7-L 8-R 56-L 1234-L] valid
Proof 8 [7-L 8-R 56-L 1234-L] valid

Tree (9) [123456789 12345678 9 1234 5678 9 _ 12 34 56 78 9 _ _ _ 1 2 3 4 5 6 7 8 9 _ _ _ _ _ _ _]
Proof 1 [1-L 2-R 34-R 5678-R 9-R] valid
Proof 2 [1-L 2-R 34-R 5678-R 9-R] valid
Proof 3 [3-L 4-R 12-L 5678-R 9-R] valid
Proof 4 [3-L 4-R 12-L 5678-R 9-R] valid
Proof 5 [5-L 6-R 78-R 1234-L 9-R] valid
Proof 6 [5-L 6-R 78-R 1234-L 9-R] valid
Proof 7 [7-L 8-R 56-L 1234-L 9-R] valid
Proof 8 [7-L 8-R 56-L 1234-L 9-R] valid
Proof 9 [9-L 12345678-L] valid
#+END_SRC

*** Merkle verify and inclusion verification

- Merkle verify algorithm :: The Merkle verify algorithm checks the Merkle proof
  for the inclusion of the specific transaction into the list of transactions of
  a block. The Merkle verify algorithm takes the hash of the transaction, the
  Merkle proof, the Merkle root received from a trusted source, and the pair
  hash function. If the Merkle proof is correct, then the specific transaction
  is included into the list of transactions of a block. The Merkle proof
  algorithm is generic. The type of the hash value is parameterized. This design
  allows to verify Merkle proofs derived from Merkle trees constructed using
  different hash functions e.g. Keccak256, SHA256. The Merkle verify algorithms
  first checks that the hash of the requested transaction is in the provided
  Merkle proof. If the hash is not found in the Merkle proof, than the
  verification fails. Next the first proof step, which will always be in the
  left position is taken as the initial hash. Then each successive proof step
  starting from the second is iteratively applied to the last computed hash in
  the correct order indicated by the left or right position of the proof step
  until consuming all proof steps. The resulting final hash is the computed
  Merkle root. The computed Merkle root is compared with the Merkle root
  received from a trusted source. If the computed Merkle root equals to the
  received Merkle root from a trusted source, that the verification of the
  Merkle proof is successful the the requested transaction is included into the
  list of transactions of a block. The Merkle verify algorithm
  - Check that the hash of the requested transaction is in the Merkle proof
  - Start computing the Merkle root from the first hash of the Merkle proof
  - Iteratively apply each successive hash in the correct order indicated by the
    position of the proof step to the last computed hash until consuming all
    proof steps and finally producing the computed Merkle hash
  - If the computed Merkle hash is equal to the Merkle hash received from a
    trusted source, then the verification is successful, and the transaction is
    included in the list of transactions of a block
  #+BEGIN_SRC go
func MerkleVerify[H comparable](
  txh H, merkleProof []Proof[H], merkleRoot H, pairHash func(H, H) H,
) bool {
  i := slices.IndexFunc(merkleProof, func(proof Proof[H]) bool {
    return proof.Hash == txh
  })
  if i == -1 {
    return false
  }
  hash := merkleProof[0].Hash
  for i := 1; i < len(merkleProof); i++ {
    proof := merkleProof[i]
    if proof.Pos == Left {
      hash = pairHash(proof.Hash, hash)
    } else {
      hash = pairHash(hash, proof.Hash)
    }
  }
  return hash == merkleRoot
}
  #+END_SRC

*** gRPC =TxProve= method

The gRPC =Tx= service provides the =TxProve= method to derive the Merkle proof
for the hash of the requested transaction. The interface of the service
#+BEGIN_SRC protobuf
message TxProveReq {
  string Hash = 1;
}

message TxProveRes {
  bytes MerkleProof = 1;
}

service Tx {
  rpc TxProve(TxProveReq) returns (TxProveRes);
}
#+END_SRC

The implementation of the =TxProve= method
- Create the iterator over the blocks in the local block store
- Defer closing the iterator
- Iterate over each block in the local block store in order. For each block
  - Iterate over each transaction of the confirmed block. For each transaction
    - If the list of transactions of the current block contains a transaction
      with the requested transaction hash, derive the Merkle proof for the
      requested transaction hash
      - Create the Merkle tree for the list of transactions of the current block
        by applying the Merkle hash algorithm
      - Derive the Merkle proof for the requested transaction hash from the
        constructed Merkle tree by applying the Merkle prove algorithm
      - Encode and return the derived Merkle proof to the caller
    - If the requested transaction hash is not found in any block in the local
      block store, return the transaction not found error
#+BEGIN_SRC go
func (s *TxSrv) TxProve(
  _ context.Context, req *TxProveReq,
) (*TxProveRes, error) {
  blocks, closeBlocks, err := chain.ReadBlocks(s.blockStoreDir)
  if err != nil {
    return nil, status.Errorf(codes.NotFound, err.Error())
  }
  defer closeBlocks()
  for err, blk := range blocks {
    if err != nil {
      return nil, status.Errorf(codes.Internal, err.Error())
    }
    for _, tx := range blk.Txs {
      if tx.Hash().String() == req.Hash {
        merkleTree, err := chain.MerkleHash(
          blk.Txs, chain.TxHash, chain.TxPairHash,
        )
        if err != nil {
          return nil, status.Errorf(codes.Internal, err.Error())
        }
        merkleProof, err := chain.MerkleProve(tx.Hash(), merkleTree)
        if err != nil {
          return nil, status.Errorf(codes.Internal, err.Error())
        }
        jmp, err := json.Marshal(merkleProof)
        if err != nil {
          return nil, status.Errorf(codes.Internal, err.Error())
        }
        res := &TxProveRes{MerkleProof: jmp}
        return res, nil
      }
    }
  }
  return nil, status.Errorf(
    codes.NotFound, fmt.Sprintf("transaction %v not found", req.Hash),
  )
}
#+END_SRC

*** gRPC =TxVerify= method

The gRPC =Tx= service provides the =TxVerify= method to verify the provided
Merkle proof against the Merkle root received from a trusted source, and check
whether the requested transaction is included into the list of transactions of a
block. The interface of the service
#+BEGIN_SRC protobuf
message TxVerifyReq {
  string Hash = 1;
  bytes MerkleProof = 2;
  string MerkleRoot = 3;
}

message TxVerifyRes {
  bool Valid = 1;
}

service Tx {
  rpc TxVerify(TxVerifyReq) returns (TxVerifyRes);
}
#+END_SRC

The implementation of the =TxProve= method
- Decode the provided hash of the requested transaction, the Merkle proof, and
  the Merkle root
- Verify that the provided Merkle proof for the requested transaction hash is
  correct, and confirm that the requested transaction is included in the list of
  transactions of a block
#+BEGIN_SRC go
func (s *TxSrv) TxVerify(
  _ context.Context, req *TxVerifyReq,
) (*TxVerifyRes, error) {
  txh, err := chain.DecodeHash(req.Hash)
  if err != nil {
    return nil, status.Errorf(codes.InvalidArgument, err.Error())
  }
  var merkleProof []chain.Proof[chain.Hash]
  err = json.Unmarshal(req.MerkleProof, &merkleProof)
  if err != nil {
    return nil, status.Errorf(codes.InvalidArgument, err.Error())
  }
  merkleRoot, err := chain.DecodeHash(req.MerkleRoot)
  if err != nil {
    return nil, status.Errorf(codes.InvalidArgument, err.Error())
  }
  valid := chain.MerkleVerify(txh, merkleProof, merkleRoot, chain.TxPairHash)
  res := &TxVerifyRes{Valid: valid}
  return res, nil
}
#+END_SRC

** Testing and usage

*** Testing Merkle hash, prove, and verify


The =TestMerkleHashProveVerify= testing process
- Generate lists of transactions starting from ["1"] to ["1".."9"] inclusive.
  For each list of transactions
  - Construct the Merkle tree for the generated list of transactions using the
    provided transaction hash function and the pair hash function
  - Print the array representation of the constructed Merkle tree
  - Start iterating over the transactions from the generated transaction list.
    For each transaction
    - Derive the Merkle proof for the transaction hash from the constructed
      Merkle tree
    - Print the derived Merkle proof
    - Verify the derived Merkle proof for the transaction hash and the
      constructed Merkle root
    - Verify that the derived Merkle proof is correct
#+BEGIN_SRC fish
go test -v -cover -coverprofile=coverage.cov ./... -run MerkleHashProveVerify
#+END_SRC

*** Testing gRPC =TxProve= and =TxVerify= methods

The =TestTxProveVerify= testing process
-
#+BEGIN_SRC fish
go test -v -cover -coverprofile=coverage.cov ./... -run TxProveVerify
#+ENDSRC

*** Using =tx prove= and =tx verify= commands
