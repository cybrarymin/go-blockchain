* State sync

** Concepts and purpose

*** Initial state synchronization

- State synchronization :: The initial state sync occurs when either the
  bootstrap node first starts and initializes a new blockchain or when a node
  syncs the confirmed state and the block store with the bootstrap node starting
  from the genesis or from a specific block number. The state sync ensures
  immutability and integrity of the blockchain by verifying signatures of the
  genesis and every block in order, re-applying every block to the confirmed
  state and the block store of every node. The state sync process is performed
  during the bootstrap of a new blockchain. In this case only the genesis is
  created and persisted, and the confirmed state of the bootstrap node is
  initialized with the genesis balances. The state sync process brings a new
  empty node or an out-of-sync node have the verified and validated confirmed
  state as per the latest confirmed block

*** Bootstrap state initialization

- Bootstrap state init :: The bootstrap state init is only performed once on the
  bootstrap node during the initialization of a new blockchain. The bootstrap
  state init creates, signs, and persists the genesis with the initial
  blockchain configuration parameters including the blockchain name, the time of
  signing the genesis, the authority account for signing the genesis and every
  proposed block, the initial owner account with the initial balance. The
  bootstrap state init process also initializes the confirmed state of the
  bootstrap node with balances from the genesis

*** Node state synchronization

- Node state sync :: The node state sync occurs every time when a new node joins
  the blockchain network and needs to verify and validate all confirmed blocks
  on the blockchain starting from the genesis. In this case the genesis is
  fetched from the bootstrap node, the genesis signature is verified, and the
  genesis is persisted to the block store. All the confirmed blocks are fetched
  either from the bootstrap node or any other know peer that has newer confirmed
  blocks that the bootstrap node. The node state sync is also performed when an
  out-of-sync node is catching up with the latest confirmed blocks on the
  blockchain. In this case the genesis and the initial confirmed blocks are
  already verified, validated, and persisted. The initial confirmed blocks are
  read and applied to the confirmed state from the local block store. Only the
  newer confirmed blocks are fetched from the bootstrap node and known peers.
  Regardless of a new node or an out-of-sync node, every fetched node including
  the genesis goes through the verification of the signature and the full
  validation in the form of the block application. Every verified, validated,
  and confirmed block is applied to the node's confirmed state and appended to
  the block store. Once the node state sync process is finished the node is
  ready to receive and relay new transactions, to receive and relay new proposed
  blocks, and to verify and validated new proposed blocks. The node state sync
  process is only executed when the node starts.

** Design and implementation

*** The state sync type

- State sync type :: The =stateSync= type implements the state sync algorithm
  and to initialize the bootstrap node or synchronize the peer node. The
  =stateSync= type contains the node configuration including the node address,
  the seed address, the key store directory, the block store directory, the
  genesis configuration; the node context for the graceful shutdown, the
  reference to the confirmed state for application of confirmed blocks read from
  the local block store or fetched from all known peers, and the reference to
  the peer discovery for fetching of the genesis and newer confirmed blocks. The
  =stateSync= type
  | ~cfg NodeCfg~           | Node configuration          |
  | ~ctx context.Context~   | Node context                |
  | ~state *chain.State~    | Confirmed and pending state |
  | ~peerReader PeerReader~ | Peer reader                 |
  #+BEGIN_SRC go
type StateSync struct {
  cfg NodeCfg
  ctx context.Context
  state *chain.State
  peerReader PeerReader
}

func NewStateSync(
  ctx context.Context, cfg NodeCfg, peerReader PeerReader,
) *StateSync {
  return &StateSync{ctx: ctx, cfg: cfg, peerReader: peerReader}
}
  #+END_SRC
*** The state synchronization algorithm

- State sync algorithm :: The state synchronization algorithm covers both the
  bootstrap node initialization and the node synchronization. The algorithms
  starts by reading the genesis from a local file system. If the genesis is not
  present, the genesis is created for the bootstrap node or is fetched from the
  bootstrap node for a peer node. In either case the genesis signature is
  verified and the new blockchain state is initialized with the genesis. Next
  the local block store is initialized if necessary. Then the confirmed blocks
  from the local block store are read and applied to the confirmed state.
  Finally the new confirmed blocks are fetched from all known peers, verified,
  validated, and applied to the confirmed state. The state synchronization
  algorithm
  - Read the genesis from the local block store. If the genesis is not present
    - For the bootstrap node create, sign, and persist the genesis
    - For a peer node fetch the genesis from the bootstrap node, verify,
      validate, and persist the genesis
  - initialize the confirmed state with the genesis
  - Initialize the local block store if necessary
  - Read, verify, validate, and apply to the confirmed state the confirmed
    blocks from the local block store
  - Fetch, verify, validate, and apply to the confirmed sate the confirmed
    blocks from all know peers
  #+BEGIN_SRC go
func (s *StateSync) SyncState() (*chain.State, error) {
  gen, err := chain.ReadGenesis(s.cfg.BlockStoreDir)
  if err != nil {
    if s.cfg.Bootstrap {
      gen, err = s.createGenesis()
      if err != nil {
        return nil, err
      }
    } else {
      gen, err = s.syncGenesis()
      if err != nil {
        return nil, err
      }
    }
  }
  valid, err := chain.VerifyGen(gen)
  if err != nil {
    return nil, err
  }
  if !valid {
    return nil, fmt.Errorf("invalid genesis signature")
  }
  s.state = chain.NewState(gen)
  err = chain.InitBlockStore(s.cfg.BlockStoreDir)
  if err != nil {
    return nil, err
  }
  err = s.readBlocks()
  if err != nil {
    return nil, err
  }
  err = s.syncBlocks()
  if err != nil {
    return nil, err
  }
  fmt.Printf("=== Sync state\n%v", s.state)
  return s.state, nil
}
  #+END_SRC

*** Creating the genesis on the bootstrap node

- Genesis creation :: The genesis creation process is performed once on the
  bootstrap node during the initialization of the blockchain. The authority
  account is created and protected with the authority account password. The
  authority account is used to sign the genesis and sign the proposed blocks on
  the blockchain. The initial owner account is created and protected with the
  owner password. The initial owner account has the initial balance on the
  blockchain. The new genesis is created by providing the blockchain name, the
  authority account address, the initial owner account address and the initial
  balance. The new genesis is signed by the authority account and is persisted
  to the local block store of the bootstrap node. The genesis creation process
  - Create and persist the authority account for signing the genesis and
    proposed blocks
  - Create and persist the initial owner account with the initial blockchain
    balance
  - Create sign the genesis with the authority account
  - Persis the genesis to the local block store of the bootstrap node
  #+BEGIN_SRC go
func (s *StateSync) createGenesis() (chain.SigGenesis, error) {
  authPass := []byte(s.cfg.AuthPass)
  if len(authPass) < 5 {
    return chain.SigGenesis{}, fmt.Errorf("authpass length is less than 5")
  }
  auth, err := chain.NewAccount()
  if err != nil {
    return chain.SigGenesis{}, err
  }
  err = auth.Write(s.cfg.KeyStoreDir, authPass)
  if err != nil {
    return chain.SigGenesis{}, err
  }
  ownerPass := []byte(s.cfg.OwnerPass)
  if len(ownerPass) < 5 {
    return chain.SigGenesis{}, fmt.Errorf("ownerpass length is less than 5")
  }
  if s.cfg.Balance == 0 {
    return chain.SigGenesis{}, fmt.Errorf("balance must be positive")
  }
  acc, err := chain.NewAccount()
  if err != nil {
    return chain.SigGenesis{}, err
  }
  err = acc.Write(s.cfg.KeyStoreDir, ownerPass)
  s.cfg.OwnerPass = "erase"
  if err != nil {
    return chain.SigGenesis{}, err
  }
  gen := chain.NewGenesis(
    s.cfg.Chain, auth.Address(), acc.Address(), s.cfg.Balance,
  )
  sgen, err := auth.SignGen(gen)
  if err != nil {
    return chain.SigGenesis{}, err
  }
  err = sgen.Write(s.cfg.BlockStoreDir)
  if err != nil {
    return chain.SigGenesis{}, err
  }
  return sgen, nil
}
  #+END_SRC

*** Fetching the genesis from the bootstrap node

- Genesis sync :: The genesis sync process is performed once per node during the
  node initialization on already initialized blockchain with the running
  bootstrap node. The genesis syn process contributes to the immutability and
  integrity of the blockchain by ensuring that exactly the same copy of the
  genesis is stored in the local block store of every node on the blockchain.
  The genesis sync process fetches the encoded and signed genesis from the
  bootstrap node by calling the =GenesisSync= method of the =Block= gRPC
  service. Then the encoded genesis is decoded. Next the genesis signature is
  verified. Finally the verified genesis is persisted to the local block store
  of the node. The genesis sync process
  - Fetch the encoded and signed genesis from the bootstrap node
  - Decode and verify the genesis signature
  - Persist the verified genesis to the local block store
  #+BEGIN_SRC go
func (s *StateSync) syncGenesis() (chain.SigGenesis, error) {
  jgen, err := s.grpcGenesisSync()
  if err != nil {
    return chain.SigGenesis{}, err
  }
  var gen chain.SigGenesis
  err = json.Unmarshal(jgen, &gen)
  if err != nil {
    return chain.SigGenesis{}, err
  }
  valid, err := chain.VerifyGen(gen)
  if err != nil {
    return chain.SigGenesis{}, err
  }
  if !valid {
    return chain.SigGenesis{}, fmt.Errorf("invalid genesis signature")
  }
  err = gen.Write(s.cfg.BlockStoreDir)
  if err != nil {
    return chain.SigGenesis{}, err
  }
  return gen, nil
}
  #+END_SRC

*** Reading confirmed blocks from the local block store

- Block reading :: The block reading process is executed every time the node is
  restarted. First the genesis is read and the state is initialized with the
  genesis. Then all confirmed blocks from the local block store are read in
  order and applied to the state. The block reading process brings the node to
  the state when the node left the last time. The block reading process creates
  an iterator over the confirmed blocks in the local block store. Each confirmed
  block returned in order by the iterator is applied to the cloned state, and,
  if successful, the cloned state is applied to the confirmed state. The block
  application process ensures integrity and immutability of the blockchain state
  on every node. The block reading process
  - Create the iterator for reading the confirmed blocks in order from the local
    block store
  - Defer closing the block iterator
  - Iterate over the confirmed blocks in order
    - Apply each block to the cloned state, if successful
    - Apply the cloned state to the confirmed state
  #+BEGIN_SRC go
func (s *StateSync) readBlocks() error {
  blocks, closeBlocks, err := chain.ReadBlocks(s.cfg.BlockStoreDir)
  if err != nil {
    return err
  }
  defer closeBlocks()
  for err, blk := range blocks {
    if err != nil {
      return err
    }
    clone := s.state.Clone()
    err = clone.ApplyBlock(blk)
    if err != nil {
      return err
    }
    s.state.Apply(clone)
  }
  return nil
}
  #+END_SRC

*** Fetching confirmed blocks from all known peers...

- Block sync :: The block sync process propagates the recent confirmed blocks
  through the blockchain network during the initialization of new nodes or the
  synchronization of out-of-sync nodes on the blockchain. The block sync process
  contributes to the immutability and integrity of the blockchain by ensuring
  that exactly the same blocks in the same order are stored on every node on the
  blockchain. For every known peer the block sync process fetches the new
  confirmed blocks starting from the block number next to the last confirmed
  block on the requesting node. Each fetched block is decoded. Then the block is
  applied to the cloned state, and, if successful, the cloned state is applied
  to the confirmed state. Finally, after successful application, the new
  confirmed blocks is persisted to the local block store. The block sync process
  - For every known peer fetch new confirmed blocks starting from the block
    number next to the last confirmed block on the requesting node
    - For every fetched block
      - Decode the fetched block
      - Apply the decoded block to the local state, if successful
      - Apply the cloned state to the confirmed state
      - Persist the confirmed block to the local block store
  #+BEGIN_SRC go
func (s *StateSync) syncBlocks() error {
  for _, peer := range s.peerReader.Peers() {
    blocks, closeBlocks, err := s.grpcBlockSync(peer)
    if err != nil {
      return err
    }
    defer closeBlocks()
    for err, jblk := range blocks {
      if err != nil {
        return err
      }
      var blk chain.SigBlock
      err = json.Unmarshal(jblk, &blk)
      if err != nil {
        return err
      }
      clone := s.state.Clone()
      err = clone.ApplyBlock(blk)
      if err != nil {
        return err
      }
      s.state.Apply(clone)
      err = blk.Write(s.cfg.BlockStoreDir)
      if err != nil {
        return err
      }
    }
  }
  return nil
}
  #+END_SRC

*** gRPC =GenesisSync= method

The gRPC =Block= service provides the =GenesisSync= method to fetch the encoded
and signed genesis from the bootstrap node. The interface of the service
#+BEGIN_SRC protobuf
message GenesisSyncReq { }

message GenesisSyncRes {
  bytes Genesis = 1;
}

service Block {
  rpc GenesisSync(GenesisSyncReq) returns (GenesisSyncRes);
}
#+END_SRC

The implementation of the =GenesisSync= method
- Read and return the encoded signed genesis
#+BEGIN_SRC go
func (s *BlockSrv) GenesisSync(
  _ context.Context, req *GenesisSyncReq,
) (*GenesisSyncRes, error) {
  jgen, err := chain.ReadGenesisBytes(s.blockStoreDir)
  if err != nil {
    return nil, status.Errorf(codes.NotFound, err.Error())
  }
  res := &GenesisSyncRes{Genesis: jgen}
  return res, nil
}
#+END_SRC

*** gRPC =BlockSync= method

The gRPC =Block= service provides the =BlockSync= method to fetch from a peer
node a server stream of the encoded and signed confirmed blocks starting from a
specified block number. The interface of the service
#+BEGIN_SRC protobuf
message BlockSyncReq {
  uint64 Number = 1;
}

message BlockSyncRes {
  bytes Block = 1;
}

service Block {
  rpc BlockSync(BlockSyncReq) returns (stream BlockSyncRes);
}
#+END_SRC

The implementation of the =BlockSync= method
- Create an iterator for confirmed blocks from the local block store
- Defer closing the block iterator
- Send every block staring from the requested block number over the server
  stream to a client
#+BEGIN_SRC go
func (s *BlockSrv) BlockSync(
  req *BlockSyncReq, stream grpc.ServerStreamingServer[BlockSyncRes],
) error {
  blocks, closeBlocks, err := chain.ReadBlocksBytes(s.blockStoreDir)
  if err != nil {
    return status.Errorf(codes.NotFound, err.Error())
  }
  defer closeBlocks()
  num, i := int(req.Number), 1
  for err, jblk := range blocks {
    if err != nil {
      return status.Errorf(codes.Internal, err.Error())
    }
    if i >= num {
      res := &BlockSyncRes{Block: jblk}
      err = stream.Send(res)
      if err != nil {
        return status.Errorf(codes.Internal, err.Error())
      }
    }
    i++
  }
  return nil
}
#+END_SRC

** Testing and usage

*** Testing gRPC =GenesisSync= method

The =TestGenesisSync= testing process
- Create and persist the genesis
- Create and initialize the state from the genesis
- Set up the gRPC block service and the gRPC block client
- Call the gRPC =GenesisSync= method to fetch the genesis
- Verify the signature of the received genesis
#+BEGIN_SRC fish
go test -v -cover -coverprofile=coverage.cov ./... -run GenesisSync
#+END_SRC

*** Testing gRPC =BlockSync= method

The =TestBlockSync= testing process
- Create and persist the genesis
- Create and initialize the state from the genesis
- Create, verify, validate and persist to the local block store several blocks
- Set up the gRPC block service and the gRPC block client
- Call the gRPC =BlockSync= method to receive the newer confirmed blocks from
  the server stream
- For each received block
  - Decode the received block
  - Verify the signature of the received block
  - Check the correct block number regarding the last confirmed block
#+BEGIN_SRC fish
go test -v -cover -coverprofile=coverage.cov ./... -run BlockSync
#+END_SRC

*** Testing the state sync

The =TestStateSync= testing process
- Set up the bootstrap node
  - Create the peer discovery without starting for the bootstrap node
  - Initialize the state on the bootstrap node by creating the genesis
  - Get the initial owner account and its balance from the genesis
  - Verify that the initial owner balance from the confirmed state on the
    bootstrap node is equal to the initial owner balance from the genesis
  - Create several confirmed blocks on the bootstrap node
  - Start the gRPC server on the bootstrap node
  - Wait for the gRPC server of the bootstrap node to start
- Set up the new node
  - Create the peer discovery without starting for the new node
  - Synchronize the state on the new node by fetching the genesis and confirmed
    blocks from the bootstrap node
  - Verify that the last block number and parent on the confirmed sates of the
    bootstrap node and the new node are equal
#+BEGIN_SRC fish
go test -v -cover -coverprofile=coverage.cov ./... -run StateSync
#+END_SRC

*** Using the =node start= CLI command

The node start command is the main entry point for initialization, starting, and
restarting of a blockchain node. There are two types of nodes on this blockchain
- Bootstrap and authority node :: The bootstrap and authority node in this
  blockchain is a single authority node that initializes the blockchain by
  creating and signing the genesis on the first start; creates, signs, proposes,
  and relays new blocks; and serves as the bootstrap node for the initial peer
  discovery. The bootstrap and authority node also accepts, validates and relays
  new transactions to other peers; streams blockchain events e.g. confirmed
  block, confirmed transaction to subscribed clients; maintains the confirmed
  and pending in-memory state, and the on-disk local block store with confirmed
  blocks
- Regular node :: The regular node participates in the peer discovery; accepts,
  validates and relays new transactions from clients to other peers; receives,
  validates, and relays new transactions and proposed blocks to other peers. The
  regular node streams blockchain events e.g. confirmed block, confirmed
  transaction to subscribed clients; maintains the confirmed and pending
  in-memory state and the on-disk local block store with confirmed blocks

The =node start= parameters
- =--node= specifies the node address
- =--bootstrap= makes the node a bootstrap node for the initial peer discovery
  and also makes the node the authority node for signing the genesis, proposing
  and signing new blocks
- =--seed= specifies the seed bootstrap address for a regular node
- =--keystore= defines the key store directory on the local file system to store
  password-protected key pairs of blockchain accounts created on the node
- =--blockstore= defines the block store directory on the local file system to
  store confirmed blocks on the blockchain
- =--chain= specifies the name of the blockchain to be included in the genesis
- =--authpass= provides a password for the authority account to sign the genesis
  and proposed blocks on the blockchain
- =--ownerpass= provides a password for the initial owner account on the
  blockchain
- =--balance= specifies the balance for the initial owner account on the
  blockchain

Options for starting a blockchain node
- Initialize the bootstrap and authority node
#+BEGIN_SRC fish
set boot localhost:1122
set authpass password
set ownerpass password
./bcn node start --node $boot --bootstrap --authpass $authpass \
  --ownerpass $ownerpass --balance 1000
# === Sync state
# * Balances and nonces
# acc 1dc6773:                        1000        0
# * Last block
# blk       0: d951443 -> 0000000
# * Pending balances and nonces
# acc 1dc6773:                        1000        0
# <=> gRPC localhost:1122
#+END_SRC
- Start already initialized the bootstrap and authority node
#+BEGIN_SRC fish
./bcn node start --node $boot --bootstrap --authpass $authpass
# === Sync state
# * Balances and nonces
# acc 1dc6773:                        1000        0
# * Last block
# blk       0: d951443 -> 0000000
# * Pending balances and nonces
# acc 1dc6773:                        1000        0
# <=> gRPC localhost:1122
#+END_SRC
- Start a regular node with the seed bootstrap address
#+BEGIN_SRC fish
set node localhost:1123
./bcn node start --node $node --seed $node
# === Sync state
# * Balances and nonces
# acc 1dc6773:                        1000        0
# * Last block
# blk       0: d951443 -> 0000000
# * Pending balances and nonces
# acc 1dc6773:                        1000        0
# <=> gRPC localhost:1123
#+END_SRC
