* Account

** Concepts and purpose

*** Account components and operations

- Account :: An account represents a /digital identity/ on the blockchain. An
  account represents /user's ownership of assets/ on the blockchain. An account
  can hold, send and receive cryptocurrency and tokens. An account has an
  associated /digital ledger/ of transactions and the /current balance/

Account components
- *Private key* is a /large randomly generated secret number/ used to control
  assets on the blockchain by signing transactions
- *Public address* is a /hash of the public key/ (derived from the private key)
  that uniquely identifies an account on the blockchain
- *Current balance* is the /amount of divisible cryptocurrency/ or /indivisible
  tokens/ controlled by the private key of an account
- *Transactions* is a time-ordered /list of debit and credit transactions/
  involving an account

Operations on an account
- *Create an account*, derive a public address, and store a password-protected
  private key
- *Sign a transaction* with the private key of an account
- *Verify a transaction signature* against the public address of the signing
  account
- *Check the current balance* of cryptocurrency and tokens
- *List transactions* enumerate debit and credit transactions involving an
  account

*** Private and public keys

Accounts on the blockchain are represented by key pairs each consisting of a
private and a public key

- Private key :: A private key is a /large randomly generated secret number/
  that is used to /derive a public key/ and /digitally sign transactions/. A
  private key *must be kept in secret* to /preserve account authenticity/ and
  /control account assets/ on the blockchain
- Public key :: A public key is a /pair of large numbers/ derived from a private
  key. A public key is used to /identify an account/ on the blockchain and
  /verify transactions/ signed with the corresponding private key. A public key
  *can be safely shared* with any participant on the blockchain

** Design and implementation

*** Elliptic-curve cryptography Secp256k1 key pair

The implementation of this blockchain uses the *elliptic-curve cryptography*
(*ECC*). Specifically, the *Secp256k1 elliptic curve* is used for generation of
key pairs for accounts on the blockchain, as well as signing and verification of
transactions on the blockchain

- Secp256k1 public key :: The public key holds the name =P-256k1= of the =Curve=
  and two large numbers =X= and =Y= derived from the corresponding private key
  #+BEGIN_SRC go
type p256k1PublicKey struct {
  Curve string `json:"curve"`
  X *big.Int `json:"x"`
  Y *big.Int `json:"y"`
}

func newP256k1PublicKey(pub *ecdsa.PublicKey) p256k1PublicKey {
  return p256k1PublicKey{Curve: "P-256k1", X: pub.X, Y: pub.Y}
}
  #+END_SRC
- Secp256k1 private key :: The private key holds the large secret number =D= and
  embeds the derived public key =p256k1PublicKey=. The ~*ecdsa.PublicKey~ and
  =*ecdsa.PrivateKey= components can be retrieved from a =p256k1PrivateKey=
  instance
  #+BEGIN_SRC go
type p256k1PrivateKey struct {
  p256k1PublicKey
  D *big.Int `json:"d"`
}

func newP256k1PrivateKey(prv *ecdsa.PrivateKey) p256k1PrivateKey {
  return p256k1PrivateKey{
    p256k1PublicKey: newP256k1PublicKey(&prv.PublicKey), D: prv.D,
  }
}

func (k *p256k1PrivateKey) publicKey() *ecdsa.PublicKey {
  return &ecdsa.PublicKey{Curve: ecc.P256k1(), X: k.X, Y: k.Y}
}

func (k *p256k1PrivateKey) privateKey() *ecdsa.PrivateKey {
  return &ecdsa.PrivateKey{PublicKey: *k.publicKey(), D: k.D}
}
  #+END_SRC

The =p256k1PublicKey= and =p256k1PrivateKey= types are used for JSON encoding
and decoding of private and public keys, which, in turn, is used for persistence
and retrieval of accounts on the blockchain

*** Account address with Keccak256 hash function

- Account address :: An account address uniquely identifies an account on the
  blockchain and can be safely shared with any participant on the blockchain. An
  account address is the /Keccak256 hash of an encoded public key/ associated
  with the account. The account =Address= is implemented as a type alias to a
  =string=. An account address is calculated from a =*ecdsa.PublicKey=
  #+BEGIN_SRC go
type Address string

func NewAddress(pub *ecdsa.PublicKey) Address {
  jpub, _ := json.Marshal(newP256k1PublicKey(pub))
  hash := make([]byte, 64)
  sha3.ShakeSum256(hash, jpub)
  return Address(hex.EncodeToString(hash[:32]))
}
  #+END_SRC

*** Account with Secp256k1 key pair

- Account :: An account contains a /Secp256k1 private key/ =prv= and an /account
  address/ =addr= derived from the corresponding Secp256k1 public key. A new
  Secp256k1 key pair is generated when a =NewAccount= is created
  #+BEGIN_SRC go
type Account struct {
  prv *ecdsa.PrivateKey
  addr Address // derived
}

func NewAccount() (Account, error) {
  prv, err := ecdsa.GenerateKey(ecc.P256k1(), rand.Reader)
  if err != nil {
    return Account{}, err
  }
  addr := NewAddress(&prv.PublicKey)
  return Account{prv: prv, addr: addr}, nil
}
  #+END_SRC

A private key is the only piece of information required to re-create an account
after persistence to a secured file controlled by the owner of an account.
Accounts on this blockchain are persisted to files with restricted access. A
private key is encrypted with a password before being persisted to a file. Only
the owner of an account can re-create and use a persisted account by providing
the password

- Account persistence :: The account persistence process
  - Encode a key pair to JSON
  - Encrypt the encoded key pair with the owner-provided password
  - Write the encrypted key pair to a file with restricted access
  #+BEGIN_SRC go
func (a Account) Write(dir string, pass []byte) error {
  jprv, err := a.encodePrivateKey()
  if err != nil {
    return err
  }
  cprv, err := encryptWithPassword(jprv, pass)
  if err != nil {
    return err
  }
  err = os.MkdirAll(dir, 0700)
  if err != nil {
    return err
  }
  path := filepath.Join(dir, string(a.Address()))
  return os.WriteFile(path, cprv, 0600)
}
  #+END_SRC

The JSON encoded key pair before encryption has the following form
#+BEGIN_SRC json
{
  "curve":"P-256k1",
  "x":76146145399705616720589739763260279141573762368317905858350098027838154138247,
  "y":38666865918508785210169373834294899085353404099611077977239116930574874120850,
  "d":4551610683346874789776802044583374602892654338372126162371523966290596962565
}
#+END_SRC

- Account re-creation :: The account re-creation process
  - Read the encrypted key pair from a file
  - Decrypt the the encrypted key pair with the owner-provided password
  - Decode the encoded key pair to a private key
  - Re-create the account from the decoded private key
  #+BEGIN_SRC go
func ReadAccount(path string, pass []byte) (Account, error) {
  cprv, err := os.ReadFile(path)
  if err != nil {
    return Account{}, err
  }
  jprv, err := decryptWithPassword(cprv, pass)
  if err != nil {
    return Account{}, err
  }
  return decodePrivateKey(jprv)
}
  #+END_SRC

*** AES-GCM encryption with Argon2 KDF of Secp256k1 key pairs

- AES-GCM encryption with Argon2 KDF :: The encryption process
  - *Argon2 key derivation function* (*KDF*) derives a cryptographically strong
    encryption key from the owner-provided password and a randomly generated
    salt
  - Create the *AES block cipher* that uses the derived cryptographically strong
    encryption key
  - Create the *AES-GCM encryption mode* from the AES block cipher
  - AES-GCM encrypts the encoded key pair with the randomly generated nonce
  - Pack the random salt, the random nonce, and the ciphertext all together into
    a slice of bytes to be written to a file. Both the salt for the Argon2 KDF
    and the nonce for the AES-GCM are public, but must be unique
    #+BEGIN_SRC go
  func encryptWithPassword(msg, pass []byte) ([]byte, error) {
    salt := make([]byte, encKeyLen)
    _, err := rand.Read(salt)
    if err != nil {
      return nil, err
    }
    key := argon2.IDKey(pass, salt, 1, 256, 1, encKeyLen)
    blk, err := aes.NewCipher(key)
    if err != nil {
      return nil, err
    }
    gcm, err := cipher.NewGCM(blk)
    if err != nil {
      return nil, err
    }
    nonce := make([]byte, gcm.NonceSize())
    _, err = rand.Read(nonce)
    if err != nil {
      return nil, err
    }
    ciph := gcm.Seal(nonce, nonce, msg, nil)
    ciph = append(salt, ciph...)
    return ciph, nil
  }
    #+END_SRC

- AES-GCM decryption with Argon2 KDF :: The decryption process
  - *Argon2 KDF* derives the encryption key from the owner-provided password and
    the random salt extracted from the ciphertext
  - Create the *AES block cipher* that uses the derived cryptographically strong
    encryption key
  - Create the *AES-GCM encryption mode* from the AES block cipher
  - AES-GCM decrypts the encoded key pair using the ciphertext and the random
    nonce extracted from the ciphertext
    #+BEGIN_SRC go
  func decryptWithPassword(ciph, pass []byte) ([]byte, error) {
    salt, ciph := ciph[:encKeyLen], ciph[encKeyLen:]
    key := argon2.IDKey(pass, salt, 1, 256, 1, encKeyLen)
    blk, err := aes.NewCipher(key)
    if err != nil {
      return nil, err
    }
    gcm, err := cipher.NewGCM(blk)
    if err != nil {
      return nil, err
    }
    nonceLen := gcm.NonceSize()
    nonce, ciph := ciph[:nonceLen], ciph[nonceLen:]
    msg, err := gcm.Open(nil, nonce, ciph, nil)
    if err != nil {
      return nil, err
    }
    return msg, nil
  }
    #+END_SRC

** Testing and usage

*** Testing account persistence and re-creation

The =TestAccountWriteReadSignTxVerifyTx= testing process
- Create a new account
- Persist the account to a file
- Re-create the account from a file
- Verify that the re-created account correctly signs and verifies transactions
#+BEGIN_SRC fish
go test -v -cover -coverprofile=coverage.cov ./... -run AccountWriteRead
#+END_SRC

*** Testing gRPC =AccountCreate= method

The blockchain node exposes the gRPC service to manage accounts on the
blockchain. The ProtoBuf definition of the gRPC service
#+BEGIN_SRC protobuf
message AccountCreateReq {
  string Password = 1;
}

message AccountCreateRes {
  string Address = 1;
}

service Account {
  rpc AccountCreate(AccountCreateReq) returns (AccountCreateRes);
}
#+END_SRC

The =TestAccountCreate= testing process
- Set up the gRPC =Account= service and the gRPC =Account= client
- Call the gRPC =AccountCreate= method with the owner-provided password to
  create a new account on the blockchain
- Verify that the returned account address length is correct
#+BEGIN_SRC fish
go test -v -cover -coverprofile=coverage.cov ./... -run AccountCreate
#+END_SRC

*** Using =account create= CLI command

The gRPC =AccountCreate= method is exposed through the CLI. To create an account
on the blockchain and store its key pair on the blockchain node run the
following commands in a terminal
- Start a blockchain node
#+BEGIN_SRC fish
./bcn node start --node localhost:1122 --bootstrap --authpass password
#+END_SRC
- Create a new account (in a new terminal)
#+BEGIN_SRC fish
./bcn account create --node localhost:1122 --ownerpass password
acc: 1a053079e900a3aedc0f67dcfc60376777ae675d1ec03722abea77c7793ecf34
#+END_SRC
