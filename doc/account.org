* Account

** Concepts and purpose

*** Account

- Account :: An account represents a /digital identity/ on the blockchain. An
  account represents /user's ownership of assets/ on the blockchain. An account
  can hold, send and receive cryptocurrency and tokens. An account has an
  associated /digital ledger/ of transactions and the /current balance/

Account components
- *Private key* is a /large randomly generated secret number/ used to control
  assets on the blockchain by signing transactions
- *Public address* is a /hash of a public key/ (derived from a private key) that
  uniquely identifies an account on the blockchain
- *Current balance* is the /amount of divisible cryptocurrency/ or /indivisible
  tokens/ controlled by a private key of an account
- *Transactions* is a time-ordered /list of debit and credit transactions/
  involving an account

Operations on an account
- *Create an account*, derive a public address, and store a password-protected
  private key
- *Sign a transaction* with the account private key
- *Verify a signed transaction* against the public address on the signing
  account
- *Check the current balance* of cryptocurrency and tokens
- *List transactions* enumerate debit and credit transactions associated with an
  account

*** Private and public key pair

Accounts on the blockchain are represented by private and public key pairs

- Private key :: A private key is a /large randomly generated secret number/
  that is used to derive a public key and /digitally sign transactions/. A
  private key must be kept in secret to /preserve account authenticity/ and
  /control account assets/
- Public key :: A public key is a /pair of large numbers/ derived from a private
  key. A public key is used to /identify an account/ on the blockchain and
  /verify transactions/ signed with the corresponding private key

*** Signing and verifying transactions

- Sign transaction :: A hash of an encoded /transaction is signed with a private
  key/. The sign operation produces a signature that is used to verify the
  signed transaction
- Verify transaction :: A /public key is recovered/ from the hash of an encoded
  transaction and the associated signature. An account address derived from the
  recovered public key is compared with the =From= address of the signed
  transaction. If both addresses match, the signature is valid. A valid
  signatures guarantees /integrity of the transaction/ (the transaction has not
  been tampered with) and /authenticity of the transaction/ (the transaction has
  been signed by the owner of the =From= account) if the account private key has
  not been compromised

** Design and implementation

*** Elliptic-curve cryptography Secp256k1 key pair

The implementation of this blockchain uses the *elliptic-curve cryptography*
(*ECC*). Specifically, the *Secp256k1 elliptic curve* is used for generation of
key pairs for the blockchain accounts and signing and verification of
transactions on the blockchain

- Secp256k1 public key :: The public key holds the name =P-256k1= of the =Curve=
  and two large numbers =X= and =Y= derived from the corresponding private key
  #+BEGIN_SRC go
type p256k1PublicKey struct {
  Curve string `json:"curve"`
  X *big.Int `json:"x"`
  Y *big.Int `json:"y"`
}

func newP256k1PublicKey(pub *ecdsa.PublicKey) p256k1PublicKey {
  return p256k1PublicKey{Curve: "P-256k1", X: pub.X, Y: pub.Y}
}
  #+END_SRC
- Secp256k1 private key :: The private key holds the large secret number =D= and
  embeds the derived public key =p256k1PublicKey=. The ~*ecdsa.PublicKey~ and
  =*ecdsa.PrivateKey= components can be retrieved from a =p256k1PrivateKey=
  instance
  #+BEGIN_SRC go
type p256k1PrivateKey struct {
  p256k1PublicKey
  D *big.Int `json:"d"`
}

func newP256k1PrivateKey(prv *ecdsa.PrivateKey) p256k1PrivateKey {
  return p256k1PrivateKey{
    p256k1PublicKey: newP256k1PublicKey(&prv.PublicKey), D: prv.D,
  }
}

func (k *p256k1PrivateKey) publicKey() *ecdsa.PublicKey {
  return &ecdsa.PublicKey{Curve: ecc.P256k1(), X: k.X, Y: k.Y}
}

func (k *p256k1PrivateKey) privateKey() *ecdsa.PrivateKey {
  return &ecdsa.PrivateKey{PublicKey: *k.publicKey(), D: k.D}
}
  #+END_SRC

The =p256k1PublicKey= and =p256k1PrivateKey= types are used for JSON encoding
and decoding of private and public keys, which, in turn, is used for persistence
and retrieval of accounts on the blockchain

*** Account address with the Keccak256 hash function

- Account address :: An account address uniquely identifies an account on the
  blockchain. An account address is the /Keccak256 hash of an encoded public
  key/ associated with the account. The account =Address= is implemented as a
  type alias to a =string=. An account address is calculated from a
  =*ecdsa.PublicKey=
  #+BEGIN_SRC go
type Address string

func NewAddress(pub *ecdsa.PublicKey) Address {
  jpub, _ := json.Marshal(newP256k1PublicKey(pub))
  hash := make([]byte, 64)
  sha3.ShakeSum256(hash, jpub)
  return Address(hex.EncodeToString(hash[:32]))
}
  #+END_SRC

*** Account with the Secp256k1 key pair

- Account :: An account contains a /Secp256k1 private key/ =prv= and an /account
  address/ =addr= derived from the corresponding Secp256k1 public key. A new
  Secp256k1 key pair is generated when a =NewAccount= is created
  #+BEGIN_SRC go
type Account struct {
  prv *ecdsa.PrivateKey
  addr Address // derived
}

func NewAccount() (Account, error) {
  prv, err := ecdsa.GenerateKey(ecc.P256k1(), rand.Reader)
  if err != nil {
    return Account{}, err
  }
  addr := NewAddress(&prv.PublicKey)
  return Account{prv: prv, addr: addr}, nil
}
  #+END_SRC

A private key is the only piece of information required to re-create an account
after persistence to a secured file controlled by the owner of the account.
Accounts on this blockchain are persisted to files with restricted access. A
private key is encrypted with a password before being persisted to a file

- Account persistence :: The account persistence process starts with /encoding
  the private key to JSON/, then /encrypts the JSON/ with an /owner-provided
  password/, and, finally, /writes the ciphertext/ to a file with restricted
  access
  #+BEGIN_SRC go
func (a Account) Write(dir string, pass []byte) error {
  jprv, err := a.encodePrivateKey()
  if err != nil {
    return err
  }
  cprv, err := encryptWithPassword(jprv, pass)
  if err != nil {
    return err
  }
  err = os.MkdirAll(dir, 0700)
  if err != nil {
    return err
  }
  path := filepath.Join(dir, string(a.Address()))
  return os.WriteFile(path, cprv, 0600)
}
  #+END_SRC

The encoded key pair before encryption
#+BEGIN_SRC json
{
  "curve":"P-256k1",
  "x":76146145399705616720589739763260279141573762368317905858350098027838154138247,
  "y":38666865918508785210169373834294899085353404099611077977239116930574874120850,
  "d":4551610683346874789776802044583374602892654338372126162371523966290596962565
}
#+END_SRC

- Account reading :: A persisted account is re-created by reading its private
  key encrypted with an owner-provided password from a file with restricted
  access. The reading process starts with /reading the ciphertext/, then
  /decrypts a private key/ with an /owner-provided password/, and, finally,
  /constructs the account/ with the address using the private key
  #+BEGIN_SRC go
func ReadAccount(path string, pass []byte) (Account, error) {
  cprv, err := os.ReadFile(path)
  if err != nil {
    return Account{}, err
  }
  jprv, err := decryptWithPassword(cprv, pass)
  if err != nil {
    return Account{}, err
  }
  return decodePrivateKey(jprv)
}
  #+END_SRC

*** AES-GCM encryption with Argon2 KDF of Secp256k1 private keys

*** ECC signing and verification of transactions

** Usage and improvements
