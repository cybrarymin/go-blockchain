* Block

** Concepts and purpose

*** Genesis and blocks

- Genesis :: The genesis file is used to initialize a blockchain. The genesis
  file contains /initial configuration parameters of the blockchain/ e.g. the
  name of the blockchain, the time of initiation of the blockchain; and the
  /initial balances of owner accounts/. The genesis file may contain other
  blockchain configuration parameters like the address of the authority account
  that signs the genesis and all blocks on the blockchain
- Block :: A block on the blockchain /contains a list of transactions/, acts as
  a /node of a linked list/ of all blocks on the blockchain, and is a /unit of
  integrity/ checking on the blockchain. A block represents a /unit of
  consensus agreement/ between nodes on the blockchain. Blocks of transactions
  are created and proposed by one nodes and validated and voted by other nodes.
  Blocks can be digitally signed by proposing, validating, and voting nodes. A
  block must be either validated and added to the blockchain with all listed
  transactions or rejected completely even if some transactions are valid

*** Chain of blocks and immutability

- Chain of blocks :: Blocks on the blockchain are organized into a /linked list
  of blocks/ where every blocks acts as a node of the linked list. Each block
  has a reference that contains the /hash of the parent block/. The parent hash
  of every block is the /linking and integrity checking mechanism/ that ensures
  /immutability/ of all blocks and contained transactions, /ordering/ of all
  blocks and contained transactions. A minimal change in content or ordering of
  blocks or contained transactions immediately results in a different hash of
  the modified block and breakage of the parent hash linking mechanism of the
  blockchain. The parent hash of the first block is the hash of the genesis

** Design and implementation

*** Genesis and signed genesis types

The implementation makes distinction between the =Genesis= type that contains on
the initial configuration of the blockchain and the =SigGenesis= type that also
contains the signature of the genesis by the authority account. Most of the
blockchain components work exclusively with the =SigGenesis= type

- =Genesis= type :: The =Genesis= type contains the initial configuration of the
  blockchain. Specifically the blockchain name, the authority account address
  that signs the genesis and all blocks, the initial balances on the blockchain
  that create the initial amount of money from thin air, the creation time the
  genesis
  | ~Chain string~                | Blockchain name           |
  | ~Authority Address~           | Authority account address |
  | ~Balances map[Address]uint64~ | Initial balances          |
  | ~Time time.Time~              | Creation time             |
  #+BEGIN_SRC go
type Genesis struct {
  Chain string `json:"chain"`
  Authority Address `json:"authority"`
  Balances map[Address]uint64 `json:"balances"`
  Time time.Time `json:"time"`
}

func NewGenesis(name string, authority, acc Address, balance uint64) Genesis {
  balances := make(map[Address]uint64, 1)
  balances[acc] = balance
  return Genesis{
    Chain: name, Authority: authority, Balances: balances, Time: time.Now(),
  }
}

func (g Genesis) Hash() Hash {
  return NewHash(g)
}
  #+END_SRC

- =SigGenesis= type :: The =SigGenesis= type embeds the =Genesis= type and
  includes the genesis signature. After the genesis is created and signed by the
  authority account, the genesis is immediately written to the genesis file
  | ~Genesis~    | Genesis content |
  | ~Sig []byte~ | Genesis signature |
  #+BEGIN_SRC go
type SigGenesis struct {
  Genesis
  Sig []byte `json:"sig"`
}

func NewSigGenesis(gen Genesis, sig []byte) SigGenesis {
  return SigGenesis{Genesis: gen, Sig: sig}
}

func (g SigGenesis) Hash() Hash {
  return NewHash(g)
}
  #+END_SRC

*** ECDSA signing and verification of genesis

This blockchain uses the *Elliptic Curve Digital Signature Algorithm* (*ECDSA*)
for signing and verification of the genesis. Specifically, the *Secp256k1
elliptic curve* is used for for signing and verification of the genesis

- Secp256k1 genesis signing :: The genesis signing process requires the
  owner-provided password and is performed from the =Account= instance. The
  signing signing process
  - Produce the Keccak256 hash of the genesis
  - Sign the Keccak256 hash of the genesis using the ECDSA algorithm on the
    Secp256k1 elliptic curve
  - Construct a signed genesis by adding the produced digital signature to
    the genesis
  #+BEGIN_SRC go
func (a Account) SignGen(gen Genesis) (SigGenesis, error) {
  hash := gen.Hash().Bytes()
  sig, err := ecc.SignBytes(a.prv, hash, ecc.LowerS | ecc.RecID)
  if err != nil {
    return SigGenesis{}, err
  }
  sgen := NewSigGenesis(gen, sig)
  return sgen, nil
}
  #+END_SRC

- Secp256k1 genesis verification :: The genesis verification process
  does not require any external information like the owner-provided password.
  The signed genesis instance contains all the necessary information to
  verify the signed genesis. The genesis verification process
  - Recover the public key from the hash of the original embedded genesis and
    the genesis signature
  - Construct the account address from the recovered public key
  - If the constructed account address is equal to the account address of the
    authority that signed the genesis, then the genesis signature is valid
  #+BEGIN_SRC go
func VerifyGen(gen SigGenesis) (bool, error) {
  hash := gen.Genesis.Hash().Bytes()
  pub, err := ecc.RecoverPubkey("P-256k1", hash, gen.Sig)
  if err != nil {
    return false, err
  }
  acc := NewAddress(pub)
  return acc == Address(gen.Authority), nil
}
  #+END_SRC

*** Persistence and re-creation of genesis

- Genesis persistence :: The genesis persistence process
  - Encode the genesis to JSON
  - Write the encoded genesis to a file
  #+BEGIN_SRC go
func (g SigGenesis) Write(dir string) error {
  jgen, err := json.Marshal(g)
  if err != nil {
    return err
  }
  err = os.MkdirAll(dir, 0700)
  if err != nil {
    return err
  }
  path := filepath.Join(dir, genesisFile)
  return os.WriteFile(path, jgen, 0600)
}
  #+END_SRC
- Genesis re-creation :: The genesis re-creation process
  - Read the encoded genesis from a file
  - Decode the genesis from JSON
  #+BEGIN_SRC go
func ReadGenesis(dir string) (SigGenesis, error) {
  path := filepath.Join(dir, genesisFile)
  jgen, err := os.ReadFile(path)
  if err != nil {
    return SigGenesis{}, err
  }
  var gen SigGenesis
  err = json.Unmarshal(jgen, &gen)
  return gen, err
}
  #+END_SRC

** Testing and usage

*** Testing genesis signing and verification

The =TestGenesisWriteReadSignGenVerifyGen= testing process
- Create and persist the authority account to sign the genesis
- Create and persist the initial owner account for the initial balance in the
  genesis
- Create the genesis by providing the name of the blockchain the authority
  account address, the initial owner account address and balance
- Sign the genesis from the authority account
- Persist the genesis to a file
- Read the genesis from a file
- Verify the signature of the signed genesis
#+BEGIN_SRC fish
go test -v -cover -coverprofile=coverage.cov ./... -run SignGenVerifyGen
#+END_SRC
